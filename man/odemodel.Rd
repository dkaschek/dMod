% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/classes.R
\name{odemodel}
\alias{odemodel}
\title{Generate Model Objects for ODEs and Sensitivities}
\usage{
odemodel(
  f,
  deriv = TRUE,
  forcings = NULL,
  events = NULL,
  outputs = NULL,
  fixed = NULL,
  estimate = NULL,
  modelname = "odemodel",
  solver = c("deSolve", "Sundials", "OrdinaryDiffEqJL"),
  gridpoints = NULL,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{f}{An object that can be converted to an \link{eqnvec}, such as a named character vector containing the ODE system.}

\item{deriv}{Logical; if TRUE, sensitivities are generated. Not supported when using the "OrdinaryDiffEqJL" solver.}

\item{forcings}{Character vector specifying the names of the forcings. Not supported when using the "OrdinaryDiffEqJL" solver.}

\item{events}{A data frame defining events with the following columns:
- "var": Character, the name of the state affected.
- "time": Character or numeric, the event time.
- "value": Character or numeric, the event value.
- "method": Character, either "replace" or "add" (see \link[deSolve]{events}).
Events must be defined here if they depend on parameters. Events with purely numeric time and value
can also be specified in \code{\link{Xs}()}.}

\item{outputs}{A named character vector specifying additional output variables. Not supported when using the "OrdinaryDiffEqJL" solver.}

\item{fixed}{Character vector naming parameters (initial values or dynamic) for which no sensitivities are required.
Specifying these will speed up the integration. Not supported when using the "OrdinaryDiffEqJL" solver.}

\item{estimate}{Character vector specifying parameters (initial values or dynamic) for which sensitivities
are computed. Overrides `fixed` if specified. Not supported when using the "OrdinaryDiffEqJL" solver.}

\item{modelname}{Character string for the name of the C file or Julia model generated.}

\item{solver}{Character string specifying the solver to use. Options are "deSolve", "Sundials", or "OrdinaryDiffEqJL".}

\item{gridpoints}{Integer specifying the minimum number of internal time points for ODE evaluation. Not supported when using the "OrdinaryDiffEqJL" solver.}

\item{verbose}{Logical; if TRUE, compiler output is printed to the R command line. Not supported when using the "OrdinaryDiffEqJL" solver.}

\item{...}{Additional arguments passed to \code{funC} for C-based solvers.}
}
\value{
If the solver is "deSolve" or "Sundials":
A list containing:
  - \code{func}: The main ODE object for "deSolve" or "Sundials".
  - \code{extended}: The ODE object with sensitivities (if applicable).

If the solver is "OrdinaryDiffEqJL":
An object with attributes:
\itemize{
  \item "equations": The ODE equations passed to the function.
  \item "variables": The dynamic variables in the system.
  \item "sensvariables": The labels of the derivatives. E.g. Prey.alpha for \eqn{\partial \text{Prey} /\partial alpha}.
  \item "parameters": The parameters in the system.
  \item "events": The events data frame, if provided.
  \item "modelname": The name of the generated Julia model.
  \item "juliacode": The generated Julia code.
}

The returned object contains two methods:
\itemize{
  \item \code{$solve(inits, dynpars, times, optionsOde = NULL)}: Solves the ODE system.
  \item \code{$senssolve(inits, dynpars, times, optionsOde = NULL)}: Solves the ODE system and computes sensitivities \eqn{\partial x(t,p) /\partial p}.
}

The returned object has class "odemodelC" for C-based solvers and "odemodelJ" for Julia-based solvers.
}
\description{
This function generates the model objects required for solving ordinary differential equations (ODEs)
with or without sensitivities. It supports different solvers and allows for the specification of events,
forcings, and outputs.
}
\details{
This function prepares ODE models for different solvers. For solvers other than "OrdinaryDiffEqJL",
it supports generating sensitivities and allows for the specification of forcings, events, outputs,
and grid points. For the "OrdinaryDiffEqJL" solver, unsupported arguments are ignored with a warning.

When using the "OrdinaryDiffEqJL" solver, the function internally calls \code{odemodelJL},
which generates Julia code to solve the ODE system and computes sensitivities using Julia's OrdinaryDiffEq library.
}
\examples{

\dontrun{

## Generate a compiled ODE model from an equation vector
## The model will not return sensitivities for "switch"
## Files will be generated in your working directory!

f <- eqnvec(A = "-k*A + switch*F")
model <- odemodel(f, forcings = "F", fixed = "switch")
print(model)

## Generate the same model from an equation list
f <- addReaction(NULL, from = "", to = "A", rate = "switch*F", description = "production")
f <- addReaction(f   , from = "A", to = "", rate = "k*A", description = "degradation")
print(f)

model <- odemodel(f, forcings = "F", fixed = "switch")
print(model)


# create forcings
forc1 <- data.frame(name = "F", time = seq(0,5, 0.1), value = sin(seq(0,5,0.1)))
forc2 <- data.frame(name = "F", time = seq(0,5, 0.1), value = exp(-seq(0,5,0.1)))
forc3 <- data.frame(name = "F", time= 0,              value = 0.1)


x <- Xs(model, forc1, condition = "forc1") + 
  Xs(model, forc2, condition = "forc2") + 
  Xs(model, forc3, condition = "forc3")

g <- Y(c(out1 = "F * A", out2 = "F"), x)

times <-  seq(0,5, 0.001)
pars <- setNames(runif(length(getParameters(x))), getParameters(x))

pred <- (g*x)(times, pars)  
plot(pred)


}
}
\seealso{
\link[deSolve]{events}, \link[cOde]{funC}, \link{Xs}, \link{odemodelJL}
}
